
/**
 * # Firestore Security Rules
 *
 * ## Core Philosophy
 * This ruleset enforces a security model that combines strict user ownership for private data with a role-based/ownership model for shared application data. The primary goal is to create highly secure, performant rules by relying on denormalized data for authorization decisions, thus avoiding slow and costly cross-document lookups wherever possible.
 *
 * ## Data Structure
 * All application data is organized under a root `artifacts/{appId}` collection, allowing for multiple application instances (e.g., dev, staging, prod) within the same Firestore project.
 * - Private user data (e.g., profiles) is stored in a segregated path: `/artifacts/{appId}/users/{userId}/...`
 * - Shared and public data (e.g., leads, staff) is stored under: `/artifacts/{appId}/public/data/...`
 *
 * ## Key Security Decisions
 * - **Default Deny**: Access is implicitly denied unless explicitly granted by a rule.
 * - **User Profile Security**: User profiles are strictly private and can only be accessed or modified by the user they belong to.
 * - **Lead Ownership**: Leads contain a denormalized `ownerId` field. Any signed-in user can view leads, but only the owner can modify or delete them. This supports collaboration while maintaining clear data ownership.
 * - **Admin-Only Access**: Management of the `/staff` collection is restricted to users with an 'Admin' role. This is enforced by checking the user's role in their profile document, a necessary trade-off for security given the current data structure.
 * - **Public Read-Only Data**: The knowledge base is publicly readable by anyone but cannot be modified through the client SDKs, as there is no defined ownership model for articles.
 *
 * ## Denormalization for Authorization
 * - **Leads**: The `Lead` document contains a denormalized `ownerId`. This allows a simple, fast rule (`resource.data.ownerId == request.auth.uid`) to control write access without needing a separate `get()` call to another collection.
 * - **Roles**: Admin access is determined by a `role` field on the `UserProfile` document. While this requires a `get()` call in the rules for `/staff` access, it centralizes role management. For future performance improvements, these roles could be mirrored in Firebase Auth Custom Claims.
 *
 * ## Structural Segregation
 * - The separation of `/users/{userId}` (private) and `/public/data` (shared) provides a clear and secure boundary. This allows for safe `list` operations on public collections without exposing private user data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user's UID matches the provided userId.
     * Used to enforce ownership of a document or data path.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    function isLeadOwner(leadId) {
      let leadData = get(/databases/$(database)/documents/leads/$(leadId)).data;
      return isOwner(leadData.ownerId);
    }

    /**
     * Checks for ownership on an existing document.
     * CRITICAL: Prevents updates/deletes on non-existent documents.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Checks if the requesting user has the 'Admin' role by looking up
     * their UserProfile document.
     * Note: This performs a 'get' operation, which has cost and performance
     * implications. Use judiciously.
     */
    function getStaffDocByAuthUid(authUid) {
      // This is not performant, but required for role checking without custom claims.
      // It queries the staff collection to find the document matching the auth UID.
      let staffDocs = firestore.collection('staff').where('authUid', '==', authUid).get();
      if (staffDocs.size() > 0) {
        return staffDocs.docs[0];
      }
      return null;
    }

    function getUserRole() {
      let staffDoc = getStaffDocByAuthUid(request.auth.uid);
      if (staffDoc != null) {
        return staffDoc.data.role;
      }
      return null;
    }

    function isAdmin() {
      return isSignedIn() && getUserRole() == 'Admin';
    }


    // ----------------------------------------------------------------------
    // Application Rules
    // ----------------------------------------------------------------------
      
    /**
      * @description Controls access to the single KPI document.
      * @path /kpis/kpi-doc
      */
    match /kpis/{docId} {
      allow get: if isSignedIn();
      allow write: if isAdmin();
    }
    
    match /articles/{articleId} {
        allow get, list: if isSignedIn();
        allow create, update, delete: if isAdmin();
    }


    /**
      * @description Controls access to sales leads.
      */
    match /leads/{leadId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isOwner(request.resource.data.ownerId);
      allow update: if isOwner(resource.data.ownerId) || isAdmin();
      allow delete: if isOwner(resource.data.ownerId) || isAdmin();

        /**
        * @description Controls access to a lead's note history.
        */
        match /noteHistory/{noteId} {
          allow list: if isSignedIn();
          allow get: if isSignedIn();
          allow create: if isOwner(get(/databases/$(database)/documents/leads/$(leadId)).data.ownerId) || isAdmin();
          allow update: if false;
          allow delete: if false;
        }
    }

    /**
      * @description Controls access to staff member data.
      */
    match /staff/{staffId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    match /notifications/{notificationId} {
      allow get, update, delete: if isOwner(resource.data.userId);
      allow create: if isSignedIn();
      // Allow a user to list only their own notifications
      allow list: if isSignedIn() && request.query.where.size() == 1 && request.query.where[0][0] == 'userId' && request.query.where[0][1] == '==' && request.query.where[0][2] == request.auth.uid;
    }

    match /todos/{todoId} {
      allow get, update, delete: if isOwner(resource.data.userId);
      allow create: if isOwner(request.resource.data.userId);
      // Allow a user to list only their own todos
      allow list: if isSignedIn() && request.query.where.size() == 1 && request.query.where[0][0] == 'userId' && request.query.where[0][1] == '==' && request.query.where[0][2] == request.auth.uid;
    }
    
    match /appointments/{appointmentId} {
      allow get, list: if isSignedIn();
      allow create: if isOwner(request.resource.data.ownerId);
      allow update, delete: if isOwner(resource.data.ownerId) || isAdmin();
    }

    match /contracts/{contractId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if isAdmin();
    }

    match /signatures/{signatureId} {
      allow get: if isSignedIn();
      allow list: if isAdmin();
      // Users can only create signatures for themselves.
      allow create: if isOwner(request.resource.data.userId);
      // Signatures are immutable.
      allow update, delete: if false;
    }
  }
}
