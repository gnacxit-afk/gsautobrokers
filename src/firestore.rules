
/**
 * # Firestore Security Rules
 *
 * ## Core Philosophy
 * This ruleset enforces a security model that combines strict user ownership for private data with a role-based/ownership model for shared application data. The primary goal is to create highly secure, performant rules by relying on denormalized data for authorization decisions, thus avoiding slow and costly cross-document lookups wherever possible.
 *
 * ## Data Structure
 * All application data is organized under a root `artifacts/{appId}` collection, allowing for multiple application instances (e.g., dev, staging, prod) within the same Firestore project.
 * - Private user data (e.g., profiles) is stored in a segregated path: `/artifacts/{appId}/users/{userId}/...`
 * - Shared and public data (e.g., leads, staff) is stored under: `/artifacts/{appId}/public/data/...`
 *
 * ## Key Security Decisions
 * - **Default Deny**: Access is implicitly denied unless explicitly granted by a rule.
 * - **User Profile Security**: User profiles are strictly private and can only be accessed or modified by the user they belong to.
 * - **Lead Ownership**: Leads contain a denormalized `ownerId` field. Any signed-in user can view leads, but only the owner can modify or delete them. This supports collaboration while maintaining clear data ownership.
 * - **Admin-Only Access**: Management of the `/staff` collection is restricted to users with an 'Admin' role. This is enforced by checking the user's role in their profile document, a necessary trade-off for security given the current data structure.
 * - **Public Read-Only Data**: The knowledge base is publicly readable by anyone but cannot be modified through the client SDKs, as there is no defined ownership model for articles.
 *
 * ## Denormalization for Authorization
 * - **Leads**: The `Lead` document contains a denormalized `ownerId`. This allows a simple, fast rule (`resource.data.ownerId == request.auth.uid`) to control write access without needing a separate `get()` call to another collection.
 * - **Roles**: Admin access is determined by a `role` field on the `UserProfile` document. While this requires a `get()` call in the rules for `/staff` access, it centralizes role management. For future performance improvements, these roles could be mirrored in Firebase Auth Custom Claims.
 *
 * ## Structural Segregation
 * - The separation of `/users/{userId}` (private) and `/public/data` (shared) provides a clear and secure boundary. This allows for safe `list` operations on public collections without exposing private user data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user's UID matches the provided userId.
     * Used to enforce ownership of a document or data path.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    function isLeadOwner(leadId) {
      let leadData = get(/databases/$(database)/documents/leads/$(leadId)).data;
      return isOwner(leadData.ownerId);
    }

    /**
     * Checks for ownership on an existing document.
     * CRITICAL: Prevents updates/deletes on non-existent documents.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Checks if the requesting user has the 'Admin' role by looking up
     * their UserProfile document.
     * Note: This performs a 'get' operation, which has cost and performance
     * implications. Use judiciously.
     */
    function isAdmin(appId) {
      // This function assumes staff profile is the source of truth for roles.
      // It finds the staff doc based on the auth UID. This is costly.
      // TODO: Consider custom claims for roles to avoid this lookup.
      let staffList = get(/databases/$(database)/documents/artifacts/$(appId)/public/data/staff?orderBy="authUid"&equalTo=request.auth.uid).docs;
      return isSignedIn() && staffList.size() > 0 && staffList[0].data.role == 'Admin';
    }
    
    function getStaffDocId(authUid) {
        // This is a placeholder for a more efficient way to get a document ID from an auth UID.
        // In a real app, you might use a /user_mappings/{authUid} collection.
        // For now, this is inefficient and should be used with caution.
        return get(/databases/$(database)/documents/staff?orderBy="authUid"&equalTo=authUid).docs[0].id;
    }


    // ----------------------------------------------------------------------
    // Application Rules
    // ----------------------------------------------------------------------

    match /artifacts/{appId} {

      /**
       * @description Controls access to a user's private profile data.
       * @path        /artifacts/{appId}/users/{userId}/profile/data
       * @allow       (create) A newly authenticated user creating their own profile.
       * @deny        (get) A user trying to read another user's profile.
       * @principle   Restricts access to a user's own data tree and enforces relational integrity.
       */
      match /users/{userId}/profile/data {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.id == userId;
        allow update: if isOwner(userId) && resource != null && request.resource.data.id == resource.data.id;
        allow delete: if false; // Profiles are generally not deleted by users.
      }
      
      /**
       * @description Controls access to the single KPI document.
       * @path /kpis/kpi-doc
       */
      match /kpis/{docId} {
        allow get: if isSignedIn();
        allow write: if isAdmin(appId);
      }


      // Match all public data collections
      match /public/data {

        /**
         * @description Controls access to sales leads. Leads can be read by any authenticated user,
         *              but can only be created, updated, or deleted by their assigned owner.
         * @path        /artifacts/{appId}/public/data/leads/{leadId}
         * @allow       (update) An authenticated user with UID 'user123' updating a lead where `resource.data.ownerId` is 'user123'.
         * @deny        (update) User 'user456' trying to update a lead owned by 'user123'.
         * @principle   Enforces document ownership for writes using a denormalized 'ownerId' field.
         */
        match /leads/{leadId} {
          allow get: if isSignedIn();
          allow list: if isSignedIn();
          allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
          allow update: if isExistingOwner(resource.data.ownerId) && request.resource.data.ownerId == resource.data.ownerId;
          allow delete: if isExistingOwner(resource.data.ownerId);

            /**
            * @description Controls access to a lead's note history.
            * @path        /artifacts/{appId}/public/data/leads/{leadId}/noteHistory/{noteId}
            * @allow       (create, list) The owner of the lead can create and read notes.
            * @principle   Subcollection access is gated by ownership of the parent document.
            */
            match /noteHistory/{noteId} {
              allow list: if isSignedIn();
              allow get: if isSignedIn();
              // Only the lead owner can create new notes
              allow create: if isLeadOwner(leadId);
              // Notes are immutable
              allow update: if false;
              allow delete: if false;
            }
        }

        /**
         * @description Controls access to knowledge base articles. These are public and read-only for all clients.
         * @path        /artifacts/{appId}/public/data/knowledge_base/{articleId}
         * @allow       (get) Any user, signed in or not, reading an article.
         * @deny        (create) Any user trying to create a new article.
         * @principle   Provides public read access while preventing all client-side modifications.
         */
        match /knowledge_base/{articleId} {
          // CRITICAL: Cannot implement owner-only writes. The 'KnowledgeBaseArticle' entity is missing an 'ownerId' or 'authorId' field.
          // Writes are disabled until the schema is updated to include an ownership field.
          allow get: if true;
          allow list: if true;
          allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
          allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
          allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
        }

        /**
         * @description Controls access to staff member data. Only administrators can read or manage staff.
         * @path        /artifacts/{appId}/public/data/staff/{staffId}
         * @allow       (list) An authenticated user whose profile has `role == 'Admin'` listing all staff.
         * @deny        (get) A non-admin user trying to read a staff document.
         * @principle   Enforces role-based access control (RBAC) for sensitive data.
         */
        match /staff/{staffId} {
          allow get: if isAdmin(appId);
          allow list: if isAdmin(appId);
          allow create: if isAdmin(appId);
          allow update: if isAdmin(appId) && resource != null;
          allow delete: if isAdmin(appId) && resource != null;
        }
      }
    }
     match /notifications/{notificationId} {
        allow get, update, delete: if isOwner(resource.data.userId);
        // Allow Admins to create notifications for anyone. Others can create notifications for lead owner changes.
        allow create: if isSignedIn();
        // Allow a user to list only their own notifications
        allow list: if isSignedIn() && request.query.where.size() == 1 && request.query.where[0][0] == 'userId' && request.query.where[0][1] == '==' && request.query.where[0][2] == request.auth.uid;
    }
    
    match /todos/{todoId} {
      allow get, list, update, delete: if isOwner(resource.data.userId);
      allow create: if isOwner(request.resource.data.userId);
    }
  }
}
